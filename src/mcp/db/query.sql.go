// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addCharacteristic = `-- name: AddCharacteristic :exec

INSERT INTO characteristics (id, holon_id, name, scale, value, unit, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type AddCharacteristicParams struct {
	ID        string
	HolonID   string
	Name      string
	Scale     string
	Value     string
	Unit      sql.NullString
	CreatedAt sql.NullTime
}

// Characteristic queries
func (q *Queries) AddCharacteristic(ctx context.Context, db DBTX, arg AddCharacteristicParams) error {
	_, err := db.ExecContext(ctx, addCharacteristic,
		arg.ID,
		arg.HolonID,
		arg.Name,
		arg.Scale,
		arg.Value,
		arg.Unit,
		arg.CreatedAt,
	)
	return err
}

const addEvidence = `-- name: AddEvidence :exec

INSERT INTO evidence (id, holon_id, type, content, verdict, assurance_level, carrier_ref, carrier_commit, valid_until, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type AddEvidenceParams struct {
	ID             string
	HolonID        string
	Type           string
	Content        string
	Verdict        string
	AssuranceLevel sql.NullString
	CarrierRef     sql.NullString
	CarrierCommit  sql.NullString
	ValidUntil     sql.NullTime
	CreatedAt      sql.NullTime
}

// Evidence queries
func (q *Queries) AddEvidence(ctx context.Context, db DBTX, arg AddEvidenceParams) error {
	_, err := db.ExecContext(ctx, addEvidence,
		arg.ID,
		arg.HolonID,
		arg.Type,
		arg.Content,
		arg.Verdict,
		arg.AssuranceLevel,
		arg.CarrierRef,
		arg.CarrierCommit,
		arg.ValidUntil,
		arg.CreatedAt,
	)
	return err
}

const addRelation = `-- name: AddRelation :exec

INSERT INTO relations (source_id, target_id, relation_type, created_at)
VALUES (?, ?, ?, ?)
`

type AddRelationParams struct {
	SourceID     string
	TargetID     string
	RelationType string
	CreatedAt    sql.NullTime
}

// Relation queries
func (q *Queries) AddRelation(ctx context.Context, db DBTX, arg AddRelationParams) error {
	_, err := db.ExecContext(ctx, addRelation,
		arg.SourceID,
		arg.TargetID,
		arg.RelationType,
		arg.CreatedAt,
	)
	return err
}

const clearAllEvidenceStaleForHolon = `-- name: ClearAllEvidenceStaleForHolon :exec
UPDATE evidence
SET is_stale = 0,
    stale_reason = NULL,
    stale_since = NULL
WHERE holon_id = ?
`

func (q *Queries) ClearAllEvidenceStaleForHolon(ctx context.Context, db DBTX, holonID string) error {
	_, err := db.ExecContext(ctx, clearAllEvidenceStaleForHolon, holonID)
	return err
}

const clearEvidenceStale = `-- name: ClearEvidenceStale :exec
UPDATE evidence
SET is_stale = 0,
    stale_reason = NULL,
    stale_since = NULL
WHERE id = ?
`

func (q *Queries) ClearEvidenceStale(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, clearEvidenceStale, id)
	return err
}

const clearHolonReverification = `-- name: ClearHolonReverification :exec
UPDATE holons
SET needs_reverification = 0,
    reverification_reason = NULL,
    reverification_since = NULL
WHERE id = ?
`

func (q *Queries) ClearHolonReverification(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, clearHolonReverification, id)
	return err
}

const countActiveHolonsByLayer = `-- name: CountActiveHolonsByLayer :many
SELECT layer, COUNT(*) as count
FROM active_holons
WHERE layer NOT IN ('DRR', 'invalid')
  AND type != 'DRR'
GROUP BY layer
`

type CountActiveHolonsByLayerRow struct {
	Layer string
	Count int64
}

// Counts working holons by layer, using active_holons view.
func (q *Queries) CountActiveHolonsByLayer(ctx context.Context, db DBTX) ([]CountActiveHolonsByLayerRow, error) {
	rows, err := db.QueryContext(ctx, countActiveHolonsByLayer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountActiveHolonsByLayerRow
	for rows.Next() {
		var i CountActiveHolonsByLayerRow
		if err := rows.Scan(&i.Layer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countArchivedHolonsByLayer = `-- name: CountArchivedHolonsByLayer :many
SELECT h.layer, COUNT(*) as count
FROM holons h
WHERE h.layer NOT IN ('DRR', 'invalid')
  AND h.type != 'DRR'
  AND EXISTS (
    SELECT 1 FROM relations r
    INNER JOIN holons drr ON drr.id = r.source_id
    WHERE r.target_id = h.id
      AND r.relation_type IN ('selects', 'rejects')
      AND (drr.type = 'DRR' OR drr.layer = 'DRR')
      AND EXISTS (
          SELECT 1 FROM evidence e
          WHERE e.holon_id = drr.id
          AND e.type IN ('implementation', 'abandonment', 'supersession')
      )
)
GROUP BY h.layer
`

type CountArchivedHolonsByLayerRow struct {
	Layer string
	Count int64
}

// Counts holons by layer that ARE selected/rejected by resolved DRRs (archived).
// INVERSE of active_holons VIEW logic. If active_holons definition changes,
// update this query accordingly. See migration v6.
func (q *Queries) CountArchivedHolonsByLayer(ctx context.Context, db DBTX) ([]CountArchivedHolonsByLayerRow, error) {
	rows, err := db.QueryContext(ctx, countArchivedHolonsByLayer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountArchivedHolonsByLayerRow
	for rows.Next() {
		var i CountArchivedHolonsByLayerRow
		if err := rows.Scan(&i.Layer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countHolonsByLayer = `-- name: CountHolonsByLayer :many
SELECT layer, COUNT(*) as count FROM holons WHERE context_id = ? GROUP BY layer
`

type CountHolonsByLayerRow struct {
	Layer string
	Count int64
}

func (q *Queries) CountHolonsByLayer(ctx context.Context, db DBTX, contextID string) ([]CountHolonsByLayerRow, error) {
	rows, err := db.QueryContext(ctx, countHolonsByLayer, contextID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountHolonsByLayerRow
	for rows.Next() {
		var i CountHolonsByLayerRow
		if err := rows.Scan(&i.Layer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countHolonsNeedingReverification = `-- name: CountHolonsNeedingReverification :one
SELECT COUNT(*) as count FROM holons WHERE needs_reverification = 1
`

func (q *Queries) CountHolonsNeedingReverification(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRowContext(ctx, countHolonsNeedingReverification)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStaleEvidence = `-- name: CountStaleEvidence :one
SELECT COUNT(*) as count FROM evidence WHERE is_stale = 1
`

func (q *Queries) CountStaleEvidence(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRowContext(ctx, countStaleEvidence)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createHolon = `-- name: CreateHolon :exec


INSERT INTO holons (id, type, kind, layer, title, content, context_id, scope, parent_id, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHolonParams struct {
	ID        string
	Type      string
	Kind      sql.NullString
	Layer     string
	Title     string
	Content   string
	ContextID string
	Scope     sql.NullString
	ParentID  sql.NullString
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
}

// query.sql
// sqlc queries for FPF database operations
// Holon queries
func (q *Queries) CreateHolon(ctx context.Context, db DBTX, arg CreateHolonParams) error {
	_, err := db.ExecContext(ctx, createHolon,
		arg.ID,
		arg.Type,
		arg.Kind,
		arg.Layer,
		arg.Title,
		arg.Content,
		arg.ContextID,
		arg.Scope,
		arg.ParentID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createRelation = `-- name: CreateRelation :exec
INSERT INTO relations (source_id, relation_type, target_id, congruence_level)
VALUES (?, ?, ?, ?)
ON CONFLICT(source_id, relation_type, target_id)
DO UPDATE SET congruence_level = excluded.congruence_level
`

type CreateRelationParams struct {
	SourceID        string
	RelationType    string
	TargetID        string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) CreateRelation(ctx context.Context, db DBTX, arg CreateRelationParams) error {
	_, err := db.ExecContext(ctx, createRelation,
		arg.SourceID,
		arg.RelationType,
		arg.TargetID,
		arg.CongruenceLevel,
	)
	return err
}

const createWaiver = `-- name: CreateWaiver :exec

INSERT INTO waivers (id, evidence_id, waived_by, waived_until, rationale, created_at)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateWaiverParams struct {
	ID          string
	EvidenceID  string
	WaivedBy    string
	WaivedUntil time.Time
	Rationale   string
	CreatedAt   sql.NullTime
}

// Waiver queries
func (q *Queries) CreateWaiver(ctx context.Context, db DBTX, arg CreateWaiverParams) error {
	_, err := db.ExecContext(ctx, createWaiver,
		arg.ID,
		arg.EvidenceID,
		arg.WaivedBy,
		arg.WaivedUntil,
		arg.Rationale,
		arg.CreatedAt,
	)
	return err
}

const getActiveRecentHolons = `-- name: GetActiveRecentHolons :many

SELECT id, type, kind, layer, title, content, context_id,
       scope, parent_id, cached_r_score, created_at, updated_at
FROM active_holons
WHERE layer NOT IN ('DRR', 'invalid')
  AND type != 'DRR'
ORDER BY updated_at DESC
LIMIT ?
`

type GetActiveRecentHolonsRow struct {
	ID           string
	Type         string
	Kind         sql.NullString
	Layer        string
	Title        string
	Content      string
	ContextID    string
	Scope        sql.NullString
	ParentID     sql.NullString
	CachedRScore sql.NullFloat64
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

// Active holon queries (exclude holons in resolved decisions)
// NOTE: Decisions are holons with type='DRR' or layer='DRR'.
// Resolution is tracked via evidence records of type 'implementation'/'abandonment'/'supersession'.
// DRRs create 'selects' relations to winner hypotheses and 'rejects' relations to rejected ones.
//
// The active_holons VIEW (migration v6) defines "active" = not selected/rejected by resolved DRR.
// Queries below use the view and add layer filters as needed.
// Returns working holons (L0/L1/L2) not belonging to resolved decisions.
// Uses active_holons view + excludes DRR/invalid layers for display purposes.
func (q *Queries) GetActiveRecentHolons(ctx context.Context, db DBTX, limit int64) ([]GetActiveRecentHolonsRow, error) {
	rows, err := db.QueryContext(ctx, getActiveRecentHolons, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveRecentHolonsRow
	for rows.Next() {
		var i GetActiveRecentHolonsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.Layer,
			&i.Title,
			&i.Content,
			&i.ContextID,
			&i.Scope,
			&i.ParentID,
			&i.CachedRScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveWaiverForEvidence = `-- name: GetActiveWaiverForEvidence :one
SELECT id, evidence_id, waived_by, waived_until, rationale, created_at FROM waivers
WHERE evidence_id = ? AND waived_until > datetime('now')
ORDER BY waived_until DESC LIMIT 1
`

func (q *Queries) GetActiveWaiverForEvidence(ctx context.Context, db DBTX, evidenceID string) (Waiver, error) {
	row := db.QueryRowContext(ctx, getActiveWaiverForEvidence, evidenceID)
	var i Waiver
	err := row.Scan(
		&i.ID,
		&i.EvidenceID,
		&i.WaivedBy,
		&i.WaivedUntil,
		&i.Rationale,
		&i.CreatedAt,
	)
	return i, err
}

const getAllActiveWaivers = `-- name: GetAllActiveWaivers :many
SELECT id, evidence_id, waived_by, waived_until, rationale, created_at FROM waivers WHERE waived_until > datetime('now') ORDER BY waived_until ASC
`

func (q *Queries) GetAllActiveWaivers(ctx context.Context, db DBTX) ([]Waiver, error) {
	rows, err := db.QueryContext(ctx, getAllActiveWaivers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Waiver
	for rows.Next() {
		var i Waiver
		if err := rows.Scan(
			&i.ID,
			&i.EvidenceID,
			&i.WaivedBy,
			&i.WaivedUntil,
			&i.Rationale,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStaleEvidence = `-- name: GetAllStaleEvidence :many
SELECT e.id, e.holon_id, e.type, e.carrier_ref,
       e.is_stale, e.stale_reason, e.stale_since,
       h.title as holon_title, h.layer as holon_layer
FROM evidence e
JOIN holons h ON e.holon_id = h.id
WHERE e.is_stale = 1
ORDER BY e.stale_since DESC
`

type GetAllStaleEvidenceRow struct {
	ID          string
	HolonID     string
	Type        string
	CarrierRef  sql.NullString
	IsStale     sql.NullInt64
	StaleReason sql.NullString
	StaleSince  sql.NullTime
	HolonTitle  string
	HolonLayer  string
}

func (q *Queries) GetAllStaleEvidence(ctx context.Context, db DBTX) ([]GetAllStaleEvidenceRow, error) {
	rows, err := db.QueryContext(ctx, getAllStaleEvidence)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllStaleEvidenceRow
	for rows.Next() {
		var i GetAllStaleEvidenceRow
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.CarrierRef,
			&i.IsStale,
			&i.StaleReason,
			&i.StaleSince,
			&i.HolonTitle,
			&i.HolonLayer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogByContext = `-- name: GetAuditLogByContext :many
SELECT id, timestamp, tool_name, operation, actor, target_id, input_hash, result, details, context_id FROM audit_log WHERE context_id = ? ORDER BY timestamp DESC
`

func (q *Queries) GetAuditLogByContext(ctx context.Context, db DBTX, contextID string) ([]AuditLog, error) {
	rows, err := db.QueryContext(ctx, getAuditLogByContext, contextID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.ToolName,
			&i.Operation,
			&i.Actor,
			&i.TargetID,
			&i.InputHash,
			&i.Result,
			&i.Details,
			&i.ContextID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogByTarget = `-- name: GetAuditLogByTarget :many
SELECT id, timestamp, tool_name, operation, actor, target_id, input_hash, result, details, context_id FROM audit_log WHERE target_id = ? ORDER BY timestamp DESC
`

func (q *Queries) GetAuditLogByTarget(ctx context.Context, db DBTX, targetID sql.NullString) ([]AuditLog, error) {
	rows, err := db.QueryContext(ctx, getAuditLogByTarget, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.ToolName,
			&i.Operation,
			&i.Actor,
			&i.TargetID,
			&i.InputHash,
			&i.Result,
			&i.Details,
			&i.ContextID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharacteristics = `-- name: GetCharacteristics :many
SELECT id, holon_id, name, scale, value, unit, created_at FROM characteristics WHERE holon_id = ?
`

func (q *Queries) GetCharacteristics(ctx context.Context, db DBTX, holonID string) ([]Characteristic, error) {
	rows, err := db.QueryContext(ctx, getCharacteristics, holonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Characteristic
	for rows.Next() {
		var i Characteristic
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Name,
			&i.Scale,
			&i.Value,
			&i.Unit,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionMembers = `-- name: GetCollectionMembers :many
SELECT source_id, congruence_level
FROM relations
WHERE target_id = ? AND relation_type = 'memberOf'
`

type GetCollectionMembersRow struct {
	SourceID        string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) GetCollectionMembers(ctx context.Context, db DBTX, targetID string) ([]GetCollectionMembersRow, error) {
	rows, err := db.QueryContext(ctx, getCollectionMembers, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionMembersRow
	for rows.Next() {
		var i GetCollectionMembersRow
		if err := rows.Scan(&i.SourceID, &i.CongruenceLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComponentsOf = `-- name: GetComponentsOf :many
SELECT source_id, congruence_level FROM relations
WHERE target_id = ? AND relation_type = 'componentOf'
`

type GetComponentsOfRow struct {
	SourceID        string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) GetComponentsOf(ctx context.Context, db DBTX, targetID string) ([]GetComponentsOfRow, error) {
	rows, err := db.QueryContext(ctx, getComponentsOf, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetComponentsOfRow
	for rows.Next() {
		var i GetComponentsOfRow
		if err := rows.Scan(&i.SourceID, &i.CongruenceLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependencies = `-- name: GetDependencies :many
SELECT target_id, relation_type, congruence_level
FROM relations
WHERE source_id = ? AND relation_type IN ('componentOf', 'constituentOf')
`

type GetDependenciesRow struct {
	TargetID        string
	RelationType    string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) GetDependencies(ctx context.Context, db DBTX, sourceID string) ([]GetDependenciesRow, error) {
	rows, err := db.QueryContext(ctx, getDependencies, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDependenciesRow
	for rows.Next() {
		var i GetDependenciesRow
		if err := rows.Scan(&i.TargetID, &i.RelationType, &i.CongruenceLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependents = `-- name: GetDependents :many
SELECT source_id, relation_type, congruence_level
FROM relations
WHERE target_id = ? AND relation_type IN ('componentOf', 'constituentOf')
`

type GetDependentsRow struct {
	SourceID        string
	RelationType    string
	CongruenceLevel sql.NullInt64
}

func (q *Queries) GetDependents(ctx context.Context, db DBTX, targetID string) ([]GetDependentsRow, error) {
	rows, err := db.QueryContext(ctx, getDependents, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDependentsRow
	for rows.Next() {
		var i GetDependentsRow
		if err := rows.Scan(&i.SourceID, &i.RelationType, &i.CongruenceLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvidenceByCarrierPattern = `-- name: GetEvidenceByCarrierPattern :many
SELECT e.id, e.holon_id, e.type, e.content, e.verdict,
       e.assurance_level, e.carrier_ref, e.carrier_hash, e.carrier_commit,
       e.is_stale, e.stale_reason, e.stale_since,
       e.valid_until, e.created_at,
       h.title as holon_title, h.layer as holon_layer
FROM evidence e
JOIN holons h ON e.holon_id = h.id
WHERE e.carrier_ref LIKE ?
  AND e.is_stale = 0
`

type GetEvidenceByCarrierPatternRow struct {
	ID             string
	HolonID        string
	Type           string
	Content        string
	Verdict        string
	AssuranceLevel sql.NullString
	CarrierRef     sql.NullString
	CarrierHash    sql.NullString
	CarrierCommit  sql.NullString
	IsStale        sql.NullInt64
	StaleReason    sql.NullString
	StaleSince     sql.NullTime
	ValidUntil     sql.NullTime
	CreatedAt      sql.NullTime
	HolonTitle     string
	HolonLayer     string
}

func (q *Queries) GetEvidenceByCarrierPattern(ctx context.Context, db DBTX, carrierRef sql.NullString) ([]GetEvidenceByCarrierPatternRow, error) {
	rows, err := db.QueryContext(ctx, getEvidenceByCarrierPattern, carrierRef)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEvidenceByCarrierPatternRow
	for rows.Next() {
		var i GetEvidenceByCarrierPatternRow
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.Content,
			&i.Verdict,
			&i.AssuranceLevel,
			&i.CarrierRef,
			&i.CarrierHash,
			&i.CarrierCommit,
			&i.IsStale,
			&i.StaleReason,
			&i.StaleSince,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.HolonTitle,
			&i.HolonLayer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvidenceByHolon = `-- name: GetEvidenceByHolon :many
SELECT id, holon_id, type, content, verdict, assurance_level, carrier_ref, carrier_hash, carrier_commit, is_stale, stale_reason, stale_since, valid_until, created_at FROM evidence WHERE holon_id = ? ORDER BY created_at DESC
`

func (q *Queries) GetEvidenceByHolon(ctx context.Context, db DBTX, holonID string) ([]Evidence, error) {
	rows, err := db.QueryContext(ctx, getEvidenceByHolon, holonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evidence
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.Content,
			&i.Verdict,
			&i.AssuranceLevel,
			&i.CarrierRef,
			&i.CarrierHash,
			&i.CarrierCommit,
			&i.IsStale,
			&i.StaleReason,
			&i.StaleSince,
			&i.ValidUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvidenceByID = `-- name: GetEvidenceByID :one
SELECT id, holon_id, type, content, verdict, assurance_level, carrier_ref, carrier_hash, carrier_commit, is_stale, stale_reason, stale_since, valid_until, created_at FROM evidence WHERE id = ? LIMIT 1
`

func (q *Queries) GetEvidenceByID(ctx context.Context, db DBTX, id string) (Evidence, error) {
	row := db.QueryRowContext(ctx, getEvidenceByID, id)
	var i Evidence
	err := row.Scan(
		&i.ID,
		&i.HolonID,
		&i.Type,
		&i.Content,
		&i.Verdict,
		&i.AssuranceLevel,
		&i.CarrierRef,
		&i.CarrierHash,
		&i.CarrierCommit,
		&i.IsStale,
		&i.StaleReason,
		&i.StaleSince,
		&i.ValidUntil,
		&i.CreatedAt,
	)
	return i, err
}

const getEvidenceWithCarrier = `-- name: GetEvidenceWithCarrier :many
SELECT id, holon_id, type, content, verdict, assurance_level, carrier_ref, carrier_hash, carrier_commit, is_stale, stale_reason, stale_since, valid_until, created_at FROM evidence WHERE carrier_ref IS NOT NULL AND carrier_ref != ''
`

func (q *Queries) GetEvidenceWithCarrier(ctx context.Context, db DBTX) ([]Evidence, error) {
	rows, err := db.QueryContext(ctx, getEvidenceWithCarrier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evidence
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.Content,
			&i.Verdict,
			&i.AssuranceLevel,
			&i.CarrierRef,
			&i.CarrierHash,
			&i.CarrierCommit,
			&i.IsStale,
			&i.StaleReason,
			&i.StaleSince,
			&i.ValidUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvidenceWithCarrierCommit = `-- name: GetEvidenceWithCarrierCommit :many
SELECT e.id, e.holon_id, e.type, e.content, e.verdict,
       e.assurance_level, e.carrier_ref, e.carrier_commit,
       e.is_stale, e.stale_reason, e.stale_since,
       e.valid_until, e.created_at,
       h.title as holon_title, h.layer as holon_layer
FROM evidence e
JOIN holons h ON e.holon_id = h.id
WHERE e.carrier_commit IS NOT NULL
  AND e.carrier_commit != ''
  AND e.carrier_ref IS NOT NULL
  AND e.carrier_ref != ''
  AND e.is_stale = 0
`

type GetEvidenceWithCarrierCommitRow struct {
	ID             string
	HolonID        string
	Type           string
	Content        string
	Verdict        string
	AssuranceLevel sql.NullString
	CarrierRef     sql.NullString
	CarrierCommit  sql.NullString
	IsStale        sql.NullInt64
	StaleReason    sql.NullString
	StaleSince     sql.NullTime
	ValidUntil     sql.NullTime
	CreatedAt      sql.NullTime
	HolonTitle     string
	HolonLayer     string
}

func (q *Queries) GetEvidenceWithCarrierCommit(ctx context.Context, db DBTX) ([]GetEvidenceWithCarrierCommitRow, error) {
	rows, err := db.QueryContext(ctx, getEvidenceWithCarrierCommit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEvidenceWithCarrierCommitRow
	for rows.Next() {
		var i GetEvidenceWithCarrierCommitRow
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.Content,
			&i.Verdict,
			&i.AssuranceLevel,
			&i.CarrierRef,
			&i.CarrierCommit,
			&i.IsStale,
			&i.StaleReason,
			&i.StaleSince,
			&i.ValidUntil,
			&i.CreatedAt,
			&i.HolonTitle,
			&i.HolonLayer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHolon = `-- name: GetHolon :one
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, needs_reverification, reverification_reason, reverification_since, created_at, updated_at FROM holons WHERE id = ? LIMIT 1
`

func (q *Queries) GetHolon(ctx context.Context, db DBTX, id string) (Holon, error) {
	row := db.QueryRowContext(ctx, getHolon, id)
	var i Holon
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Kind,
		&i.Layer,
		&i.Title,
		&i.Content,
		&i.ContextID,
		&i.Scope,
		&i.ParentID,
		&i.CachedRScore,
		&i.NeedsReverification,
		&i.ReverificationReason,
		&i.ReverificationSince,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHolonLineage = `-- name: GetHolonLineage :many
WITH RECURSIVE lineage AS (
    SELECT h.id, h.type, h.kind, h.layer, h.title, h.content, h.context_id, h.scope, h.parent_id, h.cached_r_score, h.created_at, h.updated_at, 0 as depth
    FROM holons h WHERE h.id = ?
    UNION ALL
    SELECT p.id, p.type, p.kind, p.layer, p.title, p.content, p.context_id, p.scope, p.parent_id, p.cached_r_score, p.created_at, p.updated_at, l.depth + 1
    FROM holons p
    INNER JOIN lineage l ON p.id = l.parent_id
)
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, created_at, updated_at, depth FROM lineage ORDER BY depth DESC
`

type GetHolonLineageRow struct {
	ID           string
	Type         string
	Kind         sql.NullString
	Layer        string
	Title        string
	Content      string
	ContextID    string
	Scope        sql.NullString
	ParentID     sql.NullString
	CachedRScore sql.NullFloat64
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
	Depth        int64
}

func (q *Queries) GetHolonLineage(ctx context.Context, db DBTX, id string) ([]GetHolonLineageRow, error) {
	rows, err := db.QueryContext(ctx, getHolonLineage, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHolonLineageRow
	for rows.Next() {
		var i GetHolonLineageRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.Layer,
			&i.Title,
			&i.Content,
			&i.ContextID,
			&i.Scope,
			&i.ParentID,
			&i.CachedRScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHolonTitle = `-- name: GetHolonTitle :one
SELECT title FROM holons WHERE id = ? LIMIT 1
`

func (q *Queries) GetHolonTitle(ctx context.Context, db DBTX, id string) (string, error) {
	row := db.QueryRowContext(ctx, getHolonTitle, id)
	var title string
	err := row.Scan(&title)
	return title, err
}

const getHolonsByParent = `-- name: GetHolonsByParent :many
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, needs_reverification, reverification_reason, reverification_since, created_at, updated_at FROM holons WHERE parent_id = ? ORDER BY created_at DESC
`

func (q *Queries) GetHolonsByParent(ctx context.Context, db DBTX, parentID sql.NullString) ([]Holon, error) {
	rows, err := db.QueryContext(ctx, getHolonsByParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Holon
	for rows.Next() {
		var i Holon
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.Layer,
			&i.Title,
			&i.Content,
			&i.ContextID,
			&i.Scope,
			&i.ParentID,
			&i.CachedRScore,
			&i.NeedsReverification,
			&i.ReverificationReason,
			&i.ReverificationSince,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHolonsNeedingReverification = `-- name: GetHolonsNeedingReverification :many
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, needs_reverification, reverification_reason, reverification_since, created_at, updated_at FROM holons
WHERE needs_reverification = 1
ORDER BY reverification_since DESC
`

func (q *Queries) GetHolonsNeedingReverification(ctx context.Context, db DBTX) ([]Holon, error) {
	rows, err := db.QueryContext(ctx, getHolonsNeedingReverification)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Holon
	for rows.Next() {
		var i Holon
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.Layer,
			&i.Title,
			&i.Content,
			&i.ContextID,
			&i.Scope,
			&i.ParentID,
			&i.CachedRScore,
			&i.NeedsReverification,
			&i.ReverificationReason,
			&i.ReverificationSince,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastCommit = `-- name: GetLastCommit :one
SELECT last_commit, last_commit_at
FROM fpf_state
WHERE context_id = ?
`

type GetLastCommitRow struct {
	LastCommit   sql.NullString
	LastCommitAt sql.NullTime
}

func (q *Queries) GetLastCommit(ctx context.Context, db DBTX, contextID string) (GetLastCommitRow, error) {
	row := db.QueryRowContext(ctx, getLastCommit, contextID)
	var i GetLastCommitRow
	err := row.Scan(&i.LastCommit, &i.LastCommitAt)
	return i, err
}

const getLatestHolonByContext = `-- name: GetLatestHolonByContext :one
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, needs_reverification, reverification_reason, reverification_since, created_at, updated_at FROM holons WHERE context_id = ? ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) GetLatestHolonByContext(ctx context.Context, db DBTX, contextID string) (Holon, error) {
	row := db.QueryRowContext(ctx, getLatestHolonByContext, contextID)
	var i Holon
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Kind,
		&i.Layer,
		&i.Title,
		&i.Content,
		&i.ContextID,
		&i.Scope,
		&i.ParentID,
		&i.CachedRScore,
		&i.NeedsReverification,
		&i.ReverificationReason,
		&i.ReverificationSince,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecentAuditLog = `-- name: GetRecentAuditLog :many
SELECT id, timestamp, tool_name, operation, actor, target_id, input_hash, result, details, context_id FROM audit_log ORDER BY timestamp DESC LIMIT ?
`

func (q *Queries) GetRecentAuditLog(ctx context.Context, db DBTX, limit int64) ([]AuditLog, error) {
	rows, err := db.QueryContext(ctx, getRecentAuditLog, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.ToolName,
			&i.Operation,
			&i.Actor,
			&i.TargetID,
			&i.InputHash,
			&i.Result,
			&i.Details,
			&i.ContextID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationsByTarget = `-- name: GetRelationsByTarget :many
SELECT source_id, target_id, relation_type, congruence_level, created_at FROM relations WHERE target_id = ? AND relation_type = ?
`

type GetRelationsByTargetParams struct {
	TargetID     string
	RelationType string
}

func (q *Queries) GetRelationsByTarget(ctx context.Context, db DBTX, arg GetRelationsByTargetParams) ([]Relation, error) {
	rows, err := db.QueryContext(ctx, getRelationsByTarget, arg.TargetID, arg.RelationType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Relation
	for rows.Next() {
		var i Relation
		if err := rows.Scan(
			&i.SourceID,
			&i.TargetID,
			&i.RelationType,
			&i.CongruenceLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleEvidenceByHolon = `-- name: GetStaleEvidenceByHolon :many
SELECT id, holon_id, type, content, verdict, assurance_level, carrier_ref, carrier_hash, carrier_commit, is_stale, stale_reason, stale_since, valid_until, created_at FROM evidence
WHERE holon_id = ? AND is_stale = 1
`

func (q *Queries) GetStaleEvidenceByHolon(ctx context.Context, db DBTX, holonID string) ([]Evidence, error) {
	rows, err := db.QueryContext(ctx, getStaleEvidenceByHolon, holonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evidence
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.HolonID,
			&i.Type,
			&i.Content,
			&i.Verdict,
			&i.AssuranceLevel,
			&i.CarrierRef,
			&i.CarrierHash,
			&i.CarrierCommit,
			&i.IsStale,
			&i.StaleReason,
			&i.StaleSince,
			&i.ValidUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWaiversByEvidence = `-- name: GetWaiversByEvidence :many
SELECT id, evidence_id, waived_by, waived_until, rationale, created_at FROM waivers WHERE evidence_id = ? ORDER BY created_at DESC
`

func (q *Queries) GetWaiversByEvidence(ctx context.Context, db DBTX, evidenceID string) ([]Waiver, error) {
	rows, err := db.QueryContext(ctx, getWaiversByEvidence, evidenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Waiver
	for rows.Next() {
		var i Waiver
		if err := rows.Scan(
			&i.ID,
			&i.EvidenceID,
			&i.WaivedBy,
			&i.WaivedUntil,
			&i.Rationale,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAuditLog = `-- name: InsertAuditLog :exec

INSERT INTO audit_log (id, tool_name, operation, actor, target_id, input_hash, result, details, context_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertAuditLogParams struct {
	ID        string
	ToolName  string
	Operation string
	Actor     string
	TargetID  sql.NullString
	InputHash sql.NullString
	Result    string
	Details   sql.NullString
	ContextID string
}

// Audit log queries
func (q *Queries) InsertAuditLog(ctx context.Context, db DBTX, arg InsertAuditLogParams) error {
	_, err := db.ExecContext(ctx, insertAuditLog,
		arg.ID,
		arg.ToolName,
		arg.Operation,
		arg.Actor,
		arg.TargetID,
		arg.InputHash,
		arg.Result,
		arg.Details,
		arg.ContextID,
	)
	return err
}

const listAllHolonIDs = `-- name: ListAllHolonIDs :many
SELECT id FROM holons
`

func (q *Queries) ListAllHolonIDs(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.QueryContext(ctx, listAllHolonIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHolonsByLayer = `-- name: ListHolonsByLayer :many
SELECT id, type, kind, layer, title, content, context_id, scope, parent_id, cached_r_score, needs_reverification, reverification_reason, reverification_since, created_at, updated_at FROM holons WHERE layer = ? ORDER BY created_at DESC
`

func (q *Queries) ListHolonsByLayer(ctx context.Context, db DBTX, layer string) ([]Holon, error) {
	rows, err := db.QueryContext(ctx, listHolonsByLayer, layer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Holon
	for rows.Next() {
		var i Holon
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.Layer,
			&i.Title,
			&i.Content,
			&i.ContextID,
			&i.Scope,
			&i.ParentID,
			&i.CachedRScore,
			&i.NeedsReverification,
			&i.ReverificationReason,
			&i.ReverificationSince,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEvidenceStale = `-- name: MarkEvidenceStale :exec

UPDATE evidence
SET is_stale = 1,
    stale_reason = ?,
    stale_since = CURRENT_TIMESTAMP
WHERE id = ?
`

type MarkEvidenceStaleParams struct {
	StaleReason sql.NullString
	ID          string
}

// ============================================
// CODE CHANGE AWARENESS QUERIES (v5.0.0)
// ============================================
func (q *Queries) MarkEvidenceStale(ctx context.Context, db DBTX, arg MarkEvidenceStaleParams) error {
	_, err := db.ExecContext(ctx, markEvidenceStale, arg.StaleReason, arg.ID)
	return err
}

const markHolonNeedsReverification = `-- name: MarkHolonNeedsReverification :exec
UPDATE holons
SET needs_reverification = 1,
    reverification_reason = ?,
    reverification_since = CURRENT_TIMESTAMP
WHERE id = ?
`

type MarkHolonNeedsReverificationParams struct {
	ReverificationReason sql.NullString
	ID                   string
}

func (q *Queries) MarkHolonNeedsReverification(ctx context.Context, db DBTX, arg MarkHolonNeedsReverificationParams) error {
	_, err := db.ExecContext(ctx, markHolonNeedsReverification, arg.ReverificationReason, arg.ID)
	return err
}

const recordWork = `-- name: RecordWork :exec

INSERT INTO work_records (id, method_ref, performer_ref, started_at, ended_at, resource_ledger, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type RecordWorkParams struct {
	ID             string
	MethodRef      string
	PerformerRef   string
	StartedAt      time.Time
	EndedAt        sql.NullTime
	ResourceLedger sql.NullString
	CreatedAt      sql.NullTime
}

// Work record queries
func (q *Queries) RecordWork(ctx context.Context, db DBTX, arg RecordWorkParams) error {
	_, err := db.ExecContext(ctx, recordWork,
		arg.ID,
		arg.MethodRef,
		arg.PerformerRef,
		arg.StartedAt,
		arg.EndedAt,
		arg.ResourceLedger,
		arg.CreatedAt,
	)
	return err
}

const updateHolonLayer = `-- name: UpdateHolonLayer :exec
UPDATE holons SET layer = ?, updated_at = ? WHERE id = ?
`

type UpdateHolonLayerParams struct {
	Layer     string
	UpdatedAt sql.NullTime
	ID        string
}

func (q *Queries) UpdateHolonLayer(ctx context.Context, db DBTX, arg UpdateHolonLayerParams) error {
	_, err := db.ExecContext(ctx, updateHolonLayer, arg.Layer, arg.UpdatedAt, arg.ID)
	return err
}

const updateHolonRScore = `-- name: UpdateHolonRScore :exec
UPDATE holons SET cached_r_score = ?, updated_at = ? WHERE id = ?
`

type UpdateHolonRScoreParams struct {
	CachedRScore sql.NullFloat64
	UpdatedAt    sql.NullTime
	ID           string
}

func (q *Queries) UpdateHolonRScore(ctx context.Context, db DBTX, arg UpdateHolonRScoreParams) error {
	_, err := db.ExecContext(ctx, updateHolonRScore, arg.CachedRScore, arg.UpdatedAt, arg.ID)
	return err
}

const updateLastCommit = `-- name: UpdateLastCommit :exec
UPDATE fpf_state
SET last_commit = ?,
    last_commit_at = CURRENT_TIMESTAMP
WHERE context_id = ?
`

type UpdateLastCommitParams struct {
	LastCommit sql.NullString
	ContextID  string
}

func (q *Queries) UpdateLastCommit(ctx context.Context, db DBTX, arg UpdateLastCommitParams) error {
	_, err := db.ExecContext(ctx, updateLastCommit, arg.LastCommit, arg.ContextID)
	return err
}
